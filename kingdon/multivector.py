import operator
from collections.abc import Mapping
from dataclasses import dataclass, field
from functools import reduce, cached_property
from typing import Generator
from itertools import product

from sympy import Symbol, Expr, sympify

from kingdon.codegen import _lambdify_mv


@dataclass(init=False)
class MultiVector:
    algebra: "Algebra"
    _values: tuple = field(default_factory=tuple)
    _keys: tuple = field(default_factory=tuple)

    def __new__(cls, algebra, values=None, keys=None, *, name=None, grades=None, symbolcls=Symbol):
        """
        :param algebra: Instance of :class:`~kingdon.algebra.Algebra`.
        :param keys: Keys corresponding to the basis blades in either binary rep or as strings, e.g. :code:'"e12"'.
        :param values: Values of the multivector. If keys are provided, then keys and values should
            satisfy :code:`len(keys) == len(values)`. If no keys nor grades are provided, :code:`len(values)`
            should equal :code:`len(algebra)`, i.e. a full multivector. If grades is provided,
            then :code:`len(values)` should be identical to the number of values in a multivector
            of that grade.
        :param name: Base string to be used as the name for symbolic values.
        :param grades: Optional, :class:`tuple` of grades in this multivector.
            If present, :code:`keys` is checked against these grades.
        :param symbolcls: Optional, class to be used for symbol creation. This is a :class:`sympy.Symbol` by default,
            but could be e.g. :class:`symfit.Variable` or :class:`symfit.Parameter` when the goal is to use this
            multivector in a fitting problem.
        """
        # Sanitize input
        values = values if values is not None else tuple()
        name = name if name is not None else ''
        keys = keys if keys is not None else tuple()
        if not all(isinstance(k, int) for k in keys):
            keys = tuple(k if k in algebra.bin2canon else algebra.canon2bin[k] for k in keys)
        if grades is not None:
            if not all(0 <= grade <= algebra.d for grade in grades):
                raise ValueError(f'Each grade in `grades` needs to be a value between 0 and {algebra.d}.')
        else:
            grades = tuple(range(algebra.d + 1))

        # Construct a new MV on the basis of the kind of input we received.
        if isinstance(values, Mapping):
            keys, values = zip(*values.items()) if values else (tuple(), tuple())
        elif len(values) == len(algebra) and not keys:
            keys = tuple(range(len(values)))
        elif len(values) == len(algebra.indices_for_grades[grades]) and not keys:
            keys = algebra.indices_for_grades[grades]
        elif name and not values:
            # values was not given, but we do have a name. So we are in symbolic mode.
            keys = algebra.indices_for_grades[grades] if not keys else keys
            values = tuple(symbolcls(f'{name}{algebra.bin2canon[k][1:]}') for k in keys)
        elif len(keys) != len(values):
            raise TypeError(f'Length of `keys` and `values` have to match.')

        if not all(isinstance(k, int) for k in keys):
            keys = tuple(key if key in algebra.bin2canon else algebra.canon2bin[key]
                         for key in keys)
        if any(isinstance(v, str) for v in values):
            values = tuple(val if not isinstance(val, str) else sympify(val)
                           for val in values)

        if not set(keys) <= set(algebra.indices_for_grades[grades]):
            raise ValueError(f"All keys should be of grades {grades}.")

        return cls.fromkeysvalues(algebra, keys, values)

    @classmethod
    def fromkeysvalues(cls, algebra, keys, values):
        """
        Initiate a multivector from a sequence of keys and a sequence of values.
        """
        obj = object.__new__(cls)
        obj.algebra = algebra
        obj._values = values
        obj._keys = keys
        return obj

    @classmethod
    def frommatrix(cls, algebra, matrix):
        """
        Initiate a multivector from a matrix. This matrix is assumed to be
        generated by :class:`~kingdon.multivector.MultiVector.asmatrix`, and
        thus we only read the first column of the input matrix.
        """
        obj = cls(algebra=algebra, values=matrix[:, 0])
        return obj

    def keys(self):
        return self._keys

    def values(self):
        return self._values

    def items(self):
        return zip(self._keys, self._values)

    def __len__(self):
        return len(self._values)

    def itermv(self, axis=None) -> Generator["MultiVector", None, None]:
        """
        Returns an iterator over the multivectors within this multivector.

        :param axis: Axis over which to iterate. Default is to iterate over all possible mv.
        """
        shape = self.shape()[1:]
        if not shape:
            return self
        elif axis is None:
            return (
                MultiVector.fromkeysvalues(self.algebra, keys=self.keys(), values=self[(slice(None), *indices)])
                for indices in product(*(range(n) for n in shape))
            )
        else:
            raise NotImplementedError

    def shape(self):
        """ Return the shape of the .values() attribute of this multivector. """
        if hasattr(self._values, 'shape'):
            return self._values.shape
        elif hasattr(self._values[0], 'shape'):
            return len(self), *self._values[0].shape
        else:
            return len(self),

    @cached_property
    def grades(self):
        """ Tuple of the grades present in `self`. """
        return tuple(sorted({bin(ind).count('1') for ind in self.keys()}))

    def grade(self, grades):
        """
        Returns a new  :class:`~kingdon.multivector.MultiVector` instance with
        only the selected `grades` from `self`.

        :param grades: tuple or int, grades to select.
        """
        if isinstance(grades, int):
            grades = (grades,)
        elif not isinstance(grades, tuple):
            grades = tuple(grades)

        vals = {k: self[k]
                for k in self.algebra.indices_for_grades[grades] if k in self.keys()}
        return self.fromkeysvalues(self.algebra, tuple(vals.keys()), tuple(vals.values()))

    @cached_property
    def type_number(self) -> int:
        return int(''.join('1' if i in self.keys() else '0' for i in reversed(self.algebra.canon2bin.values())), 2)

    @cached_property
    def issymbolic(self):
        """ True if this mv contains Symbols, False otherwise. """
        return any(isinstance(v, Expr) for v in self.values())

    def __neg__(self):
        try:
            values = - self.values()
        except TypeError:
            values = tuple(-v for v in self.values())
        return self.fromkeysvalues(self.algebra, self.keys(), values)

    def __invert__(self):  # reversion
        values = tuple(- v if k in self.algebra._reverse_keys else v for k, v in self.items())
        return self.fromkeysvalues(self.algebra, self.keys(), values)

    def normsq(self):
        return self.algebra.normsq(self)

    def norm(self):
        normsq = self.normsq()
        if normsq.grades == (0,):
            return normsq.values()[0] ** 0.5
        else:
            raise NotImplementedError

    def normalized(self):
        """ Normalized version of this multivector. """
        return self / self.norm()

    def inv(self):
        """ Inverse of this multivector. """
        return self.algebra.inv(self)

    def __add__(self, other):
        if not isinstance(other, MultiVector):
            other = self.fromkeysvalues(self.algebra, (0,), (other,))
        vals = dict(self.items())
        for k, v in other.items():
            if k in vals:
                vals[k] += v
            else:
                vals[k] = v
        return self.fromkeysvalues(self.algebra, tuple(vals.keys()), tuple(vals.values()))

    __radd__ = __add__

    def __sub__(self, other):
        return self + (-other)

    def __rsub__(self, other):
        return other + (-self)

    def __truediv__(self, other):
        return self.algebra.div(self, other)

    def __str__(self):
        if not len(self.values()):
            return '0'

        def print_value(val):
            if isinstance(val, Expr):
                if val.is_Symbol:
                    return f"{val}"
                else:
                    return f"({val})"
            elif isinstance(val, float):
                return f'{val:.3}'
            else:
                return f'{val}'

        canon_vals = {self.algebra._bin2canon_prettystr[key]: val for key, val in self.items()}
        canon_sorted_vals = sorted(canon_vals.items(), key=lambda x: (len(x[0]), x[0]))
        str_repr = ' + '.join(
            [f'{print_value(val)} {blade}' if blade != '1' else f'{print_value(val)}'
             for blade, val in canon_sorted_vals if (val.any() if hasattr(val, 'any') else val)]
        )
        return str_repr

    def _repr_pretty_(self, p, cycle):
        if cycle:
            p.text(f'{self.__class__.__name__}(...)')
        else:
            p.text(str(self))

    def __format__(self, format_spec):
        if format_spec == 'keys_binary':
            iden = '_'.join(''.join('1' if i in self.keys() else '0' for i in bin_blades)
                            for bin_blades in self.algebra.indices_for_grade.values())
            return iden

    def __getitem__(self, item):
        if isinstance(item, tuple):
            key, *subslices = item
        else:
            key, subslices = item, tuple()

        # TODO: We could turn slices into the valid range in binary rep.
        #  This is complicated by the fact that the binary keys do not
        #  form a consecutive range.
        if not isinstance(key, slice):
            # Convert key from a basis-blade in binary rep to a valid index in values.
            key = key if key in self.algebra.bin2canon else self.algebra.canon2bin[key]
            try:
                key = self.keys().index(key)
            except ValueError:
                return 0

        values = self.values()
        if isinstance(values, (tuple, list)):
            keys = [key] if key != slice(None) else [self.keys().index(k) for k in self.keys()]
            return_values = []
            for key in keys:
                return_values.append(values[key])
                for subslice in subslices:
                    return_values[key] = return_values[key][subslice]
            if len(keys) == 1:
                return_values = return_values[0]
        else:
            return_values = values[(key, *subslices)]
        return return_values

    def __contains__(self, item):
        item = item if item in self.algebra.bin2canon else self.algebra.canon2bin[item]
        return item in self._keys

    @cached_property
    def free_symbols(self):
        return reduce(operator.or_, (v.free_symbols for v in self.values() if hasattr(v, "free_symbols")))

    def subs(self, *args, **kwargs) -> "MultiVector":
        if not self.issymbolic:
            return self
        vals = tuple(v.subs(*args, **kwargs) if isinstance(v, Expr) else v
                     for v in self.values())
        return self.fromkeysvalues(self.algebra, keys=self.keys(), values=vals)

    @cached_property
    def _callable(self):
        """ Return the callable function for this MV. """
        return _lambdify_mv({k.name: k for k in sorted(self.free_symbols, key=lambda x: x.name)}, self)

    def __call__(self, *args, **kwargs):
        if not self.free_symbols:
            return self
        keys_out, func = self._callable
        values = func(*args, **kwargs)
        return self.fromkeysvalues(self.algebra, keys_out, values)

    def asmatrix(self):
        """ Returns a matrix representation of this multivector. """
        return sum(v * self.algebra.matrix_basis[k] for k, v in self.items())

    def asdensemv(self, canonical=True):
        """
        Returns a dense version of the same multivector.

        :param canonical: If True (default) the values are in canonical order,
          even if the mutivector was already dense.
        """
        if canonical:
            keys = self.algebra.indices_for_grades[tuple(range(self.algebra.d + 1))]
        else:
            keys = tuple(range(len(self.algebra)))
        values = tuple(self[k] for k in keys)
        return self.fromkeysvalues(self.algebra, keys=keys, values=values)

    def gp(self, other):
        return self.algebra.gp(self, other)

    __mul__ = __rmul__ = gp

    def sw(self, other):
        """
        Apply :code:`x := self` to :code:`y := other` under conjugation:
        :code:`x.sw(y) = x*y*~x`.
        """
        return self.algebra.sw(self, other)

    __rshift__ = sw

    def proj(self, other):
        """
        Project :code:`x := self` onto :code:`y := other`: :code:`x @ y = (x | y) * ~y`.
        For correct behavior, :code:`x` and :code:`y` should be normalized (k-reflections).
        """
        return self.algebra.proj(self, other)

    __matmul__ = proj

    def cp(self, other):
        """
        Calculate the commutator product of :code:`x := self` and :code:`y := other`:
        :code:`x.cp(y) = 0.5*(x*y-y*x)`.
        """
        return self.algebra.cp(self, other)

    def acp(self, other):
        """
        Calculate the anti-commutator product of :code:`x := self` and :code:`y := other`:
        :code:`x.cp(y) = 0.5*(x*y+y*x)`.
        """
        return self.algebra.acp(self, other)

    def ip(self, other):
        return self.algebra.ip(self, other)

    __or__ = ip

    def op(self, other):
        return self.algebra.op(self, other)

    __xor__ = __rxor__ = op

    def lc(self, other):
        return self.algebra.lc(self, other)

    def rc(self, other):
        return self.algebra.rc(self, other)

    def sp(self, other):
        """ Scalar product: :math:`\langle x \cdot y \rangle`. """
        return self.algebra.sp(self, other)

    def rp(self, other):
        return self.algebra.rp(self, other)

    __and__ = rp

    def __pow__(self, power, modulo=None):
        # TODO: this should also be taken care of via codegen, but for now this workaround is ok.
        if power == 2:
            return self.algebra.gp(self, self)
        else:
            raise NotImplementedError

    def outerexp(self):
        return self.algebra.outerexp(self)

    def outersin(self):
        return self.algebra.outersin(self)

    def outercos(self):
        return self.algebra.outercos(self)

    def outertan(self):
        return self.algebra.outertan(self)

    def dual(self, kind='auto'):
        """
        Compute the dual of `self`. There are three different kinds of duality in common usage.
        The first is polarity, which is simply multiplying by the inverse PSS. This is the only game in town for
        non-degenerate metrics (Algebra.r = 0). However, for degenerate spaces this no longer works, and we have
        two popular options: PoincarÃ© and Hodge duality.

        By default, :code:`kingdon` will use polarity in non-degenerate spaces, and Hodge duality for spaces with
        `Algebra.r = 1`. For spaces with `r > 2`, little to no literature exists, and you are on your own.

        :param kind: if 'auto' (default), :code:`kingdon` will try to determine the best dual on the
            basis of the signature of the space. See explenation above.
            To ensure polarity, use :code:`kind='polarity'`, and to ensure Hodge duality,
            use :code:`kind='hodge'`.
        """
        if kind == 'polarity' or kind == 'auto' and self.algebra.r == 0:
            return self / self.algebra.pss
        elif kind == 'hodge' or kind == 'auto' and self.algebra.r == 1:
            return self.algebra.multivector(
                {len(self.algebra) - 1 - eI: self.algebra.signs[eI, len(self.algebra) - 1 - eI] * val
                 for eI, val in self.items()}
            )
        elif kind == 'auto':
            raise Exception('Cannot select a suitable dual in auto mode for this algebra.')
        else:
            raise ValueError(f'No dual found for kind={kind}.')

    def undual(self, kind='auto'):
        """
        Compute the undual of `self`. See :class:`~kingdon.multivector.MultiVector.dual` for more information.
        """
        if kind == 'polarity' or kind == 'auto' and self.algebra.r == 0:
            return self * self.algebra.pss
        elif kind == 'hodge' or kind == 'auto' and self.algebra.r == 1:
            return self.algebra.multivector(
                {len(self.algebra) - 1 - eI: self.algebra.signs[len(self.algebra) - 1 - eI, eI] * val
                 for eI, val in self.items()}
            )
        elif kind == 'auto':
            raise Exception('Cannot select a suitable undual in auto mode for this algebra.')
        else:
            raise ValueError(f'No undual found for kind={kind}.')
